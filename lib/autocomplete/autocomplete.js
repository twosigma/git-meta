#!/usr/bin/env node
/*
 * Copyright (c) 2016, Two Sigma Open Source
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of git-meta nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
"use strict";

/**
 * This module contains the bash autocomplete functionality for `git-meta`
 */

const co 	   = require('co');
const omelette = require('omelette');

const branch     = require("./../metac/metac_branch");
const checkout   = require("./../metac/metac_checkout");
const cherryPick = require("./../metac/metac_cherrypick");
const close      = require("./../metac/metac_close");
const commit     = require("./../metac/metac_commit");
const include    = require("./../metac/metac_include");
const merge      = require("./../metac/metac_merge");
const open       = require("./../metac/metac_open");
const pull       = require("./../metac/metac_pull");
const push       = require("./../metac/metac_push");
const rebase     = require("./../metac/metac_rebase");
const status     = require("./../metac/metac_status");
const version    = require("./../metac/metac_version");

const GitUtil    = require("./../metau/metau_gitutil");


const isOption = function(arg) {
	return arg.indexOf("-") == 0;
}

exports.isCompletion = function() {
	const completionArg = "--compgen";
	const configArg = "--completion";
	return process.argv.indexOf(completionArg) > -1
		|| process.argv.indexOf(configArg) > -1;
}

exports.autocomplete = co.wrap(function *() {
	const meta = omelette('git-meta');
	const parser = require('./parser');

	var metac = [branch, checkout, cherryPick, close, commit, include, merge, open, pull, push, rebase, status, version];

	for (var i = 0; i < 13; ++i) {
		// TODO (edy): don't set commandName
		parser.commandName = metac[i].command;
		metac[i].configureParser(parser);
	}

	// Complete event is emitted by omelette when it detects a tab completion

	meta.on("complete", co.wrap(function *(frag, word, line) {
		const args = line.split(" ");
	
		let currentCommand = parser.completers, currentOption, currentCompleter;

		// Ignore first argument as it will be `git-meta`
		// continue to parse arguments to predict how to complete

		for (let i = 1; i < args.length - 1; ++i) {
			const arg = args[i];

			// If there is an active completer, it has been fulfilled since there
			// is a next argument
			if (currentCompleter) {
				currentCompleter = null;
				continue;
			}

			currentCompleter = null;
			currentOption = null;

			// If the argument being parsed is an option, then search the current 
			// command for that option

			if (isOption(arg)) {
				if (arg in currentCommand.options) {
					currentOption = currentCommand.options[arg];
					currentCompleter = currentOption.completer;
				}
			}

			// Else if the argument is not an option, then it could be a nested command

			else if (currentCommand.commands && arg in currentCommand.commands) {
				currentCommand = currentCommand.commands[arg];
			} 

			// Otherwise, assume it to be a positional argument. If there are no possible 
			// arguments, simply return no possibilites

			else {
				if (!currentCommand.positionals || currentCommand.positionals.length == 0) {
					return this.reply([]);
				}
				currentCommand.positionals.shift();
			}
		}

		// At this point:
		// currentCommand will point to a obj with possibly options or positional arguments.
		// currentOption will be either null or point to a selected option
		// currentCompleter will be either null or point to a completer

		const lastArg = args[args.length - 1];

		// If there is a completer, return the values generated by the completer

		if (currentCompleter) {
			return yield currentCompleter(lastArg);
		} 

		// Else if its an option (--), return possible completions
		else if (isOption(lastArg)) {
			return this.reply(Object.keys(currentCommand.options).filter(opt => opt.indexOf(lastArg) > -1));
		}

		// Then match subcommands
		else if (currentCommand.commands) {
			return this.reply(Object.keys(currentCommand.commands).filter(cmd => cmd.indexOf(lastArg) > -1));
		}

		// Ensure there are no positionals left
		else if (currentCommand.positionals.length > 0) {
			const posi = currentCommand.positionals.shift();
			if (posi.completer) {
				const options = yield posi.completer(lastArg);
				return this.reply(options);
			} else {
				return this.reply([posi.defaultValue]);
			}
		}

		// Finally, give up and return no possible values
		return this.reply([]);

	}));

	meta.init();
});
